/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon 
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
#include <memory>

#include "kernels/DGBasisFunctions.h"
//#include "kernels/GaussLegendreQuadrature.h"
#if defined(_GLL)
#include "kernels/GaussLobattoQuadrature.h"
#else
#include "kernels/GaussLegendreQuadrature.h"
#endif
#include "peano/utils/Loop.h"

#include "kernels/aderdg/generic/Kernels.h"
#include <algorithm>

#include "kernels/DGMatrices.h"
#include <cstring>
#include "../../../../KernelUtils.h"

#if DIMENSIONS == 3

template <typename SolverType>
void kernels::aderdg::generic::c::deltaDistribution(
    SolverType& solver,
    const double t,
    const double dt,
    const tarch::la::Vector<DIMENSIONS, double>& center,
    const tarch::la::Vector<DIMENSIONS, double>& dx,
    const int numberOfVariables, 
    const int numberOfParameters, 
    const int basisSize,
    double* pointForceSources //memory space for forceVector
) { 
  //TODO KD

  //double x0[3];

  //idx5 idx_pointForceSources(basisSize + 1, basisSize, basisSize, basisSize,
  //               numberOfVariables);
  //loop over all quadrature point
  //do your stuff to get ready to get the value for one quadrature pointer
  //solver.pointSource(x, t, dt, &pointForceSources[idx_pointForceSources(0,ndof1,ndof2,ndof3,0)], &x0);
  //apply the result for this quadrature point


  int order = basisSize - 1;


  double x0[DIMENSIONS];
  double x[DIMENSIONS];


  idx5 idx_pointForceSources(basisSize + 1, basisSize, basisSize, basisSize,
                             numberOfVariables);
  
  idx5 idx_forceVectorSourceN(basisSize + 1, basisSize, basisSize, basisSize,
                             numberOfVariables);

 
  double* PSi                = pointForceSources; 
  double* forceVectorSourceN = pointForceSources+idx_pointForceSources(basisSize, basisSize-1, basisSize-1, basisSize-1, numberOfVariables-1) + 1;

  std::fill_n(PSi               ,(basisSize + 1) * basisSize * basisSize * basisSize * numberOfVariables,0);
  
  //loop over all point sources
  for (int m =0 ; m < solver.usePointSource() ; m++){
    std::fill_n(forceVectorSourceN,(basisSize + 1) * basisSize * basisSize * basisSize * numberOfVariables,0);      
    //loop over all quadrature point
    for (int n = 0; n < basisSize+1; n++) { // time loop
      double tn;
      if (n == 0){
	tn = t;
      }
      else {
	tn = dt* gaussLegendreNodes[order][n-1] + t;
      }

      for (int i = 0; i < basisSize; i++) {   //x loop
      #if defined(_GLL)
      double node = gaussLobattoNodes[basisSize-1][basisSize-1-i];
#else
      double node = gaussLegendreNodes[basisSize-1][i];      
#endif  
	x[2] = center[2] + dx[2] * (node - 0.5);
	for (int j = 0; j < basisSize; j++) {  //y loop
	#if defined(_GLL)
      double node = gaussLobattoNodes[basisSize-1][basisSize-1-j];
#else
      double node = gaussLegendreNodes[basisSize-1][j];      
#endif  
	  x[1] = center[1] + dx[1] * (node - 0.5);
	  for (int k = 0; k < basisSize; k++) {  //z loop

	  #if defined(_GLL)
      double node = gaussLobattoNodes[basisSize-1][basisSize-1-k];
#else
      double node = gaussLegendreNodes[basisSize-1][k];      
#endif  
	    x[0] = center[0] + dx[0] * (node - 0.5);

	    // get the source vector located at x0 = (x, y,z) and at tn = t; and at the quadrature nodes tn
	    solver.pointSource(x, tn, dt, &forceVectorSourceN[idx_forceVectorSourceN(n,i,j,k,0)], &x0[0], m);

	    // position the source inside the dG cell
	    const tarch::la::Vector<DIMENSIONS, double> _x(x0[0], x0[1], x0[2]);
	    const tarch::la::Vector<DIMENSIONS, double> offsetOfPatch = center - dx / 2.;
	    const tarch::la::Vector<DIMENSIONS, double> sizeOfPatch = dx;  // / 2.;




	    /** Generation of a point source **/

	    // Map coordinate vector x0 onto reference element
	    tarch::la::Vector<DIMENSIONS, double> xRef = _x - offsetOfPatch;
	    xRef(0) /= sizeOfPatch(0);
	    xRef(1) /= sizeOfPatch(1);
	    xRef(2) /= sizeOfPatch(2);


	    if (xRef(0) >= 0. && xRef(1) >= 0. && xRef(2) >= 0. && xRef(0) <= 1.0 &&
		xRef(1) <= 1.0 && xRef(2) <= 1.0) {

	      for (int unknown = 0; unknown < numberOfVariables /*numberOfParameters*/;
		   unknown++) {


		double value = kernels::basisFunctions[order][i](xRef(2)) *
                  kernels::basisFunctions[order][j](xRef(1)) *
                  kernels::basisFunctions[order][k](xRef(0)) *
                  forceVectorSourceN[idx_forceVectorSourceN(n,i,j,k,unknown)];

	  #if defined(_GLL)
	    double weight_1 = kernels::gaussLobattoWeights[order][i];
	    double weight_2 = kernels::gaussLobattoWeights[order][j];
	    double weight_3 = kernels::gaussLobattoWeights[order][k];	
          #else
	    double weight_1 = kernels::gaussLegendreWeights[order][i];
	    double weight_2 = kernels::gaussLegendreWeights[order][j];
	    double weight_3 = kernels::gaussLegendreWeights[order][k];	
          #endif   
		value /= (weight_3*dx[2]*
			 weight_2*dx[1]*
			 weight_1*dx[0]);

		pointForceSources[idx_pointForceSources(n,i,j,k,unknown)] += value;

		//}  // dfor
	      } // for

	    }  // endif xRef inside the domain

	    else {
	      for (int unknown = 0; unknown < numberOfVariables /*numberOfParameters*/;
		   unknown++) {

		pointForceSources[idx_pointForceSources(n,i,j,k,unknown)] += 0.0;

	      } //end unknown
	    }//endif else

	  }// z loop
	}// y loop
      }// x loop
    }// time loop
  }

  //apply the result for this quadrature point

  //idx5 idx_pointForceSources(basisSize + 1, basisSize, basisSize, basisSize, numberOfVariables);
  //loop over all quadrature point
  //do your stuff to get ready to get the value for one quadrature pointer
  //solver.pointSource(x, t, dt, &pointForceSources[idx_pointForceSources(0,ndof1,ndof2,ndof3,0)], &x0);
  //apply the result for this quadrature point
}

#endif  // DIMENSIONS == 3
