// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============


//**********************************
//**********************************
//***** USE ONLY FOR DEBUGGING *****
//**********************************
//**********************************

/*
  README
  ------
  
  This abstractsolver implementation uses the converter to be able to switch some optimised kernels
  with the generic ones. Just change the corresponding boolean hardcoded value in the corresponding
  method. By default uses the optimised code.
  
  This may help identify a faulty optimised kernel.
  
  This implementation is not always maintained and might be deprecated.

  Doesn't work with notimeavg
*/

#include "{{abstractSolver}}.h"
#include "{{optKernelPath}}/Kernels.h"
#include "{{optKernelPath}}/converter.h"

#include "kernels/aderdg/generic/Kernels.h"

#include "{{solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>

// We define the constructor of the actual solver here in order to regenerate it easily.
{{project}}::{{solver}}::{{solver}}(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,int limiterHelperLayers,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs {%- if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}{% if hasConstants %}, exahype::Parser::ParserView constants{% endif %}):
  {{abstractSolver}}::{{abstractSolver}}(maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,limiterHelperLayers,timeStepping {%- if enableProfiler %}, std::move(profiler) {%- endif %}) {
  init(cmdlineargs {%- if hasConstants %}, constants{% endif %});
}



{{project}}::{{abstractSolver}}::{{abstractSolver}}(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,int limiterHelperLayers,exahype::solvers::Solver::TimeStepping timeStepping {%- if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler {%- endif %} ):
  exahype::solvers::ADERDGSolver("{{solver}}",{{optNamespace}}::getNumberOfVariable(),{{optNamespace}}::getNumberOfParameter(),{{optNamespace}}::getBasisSize(),
                                 maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,limiterHelperLayers,timeStepping {%- if enableProfiler %}, std::move(profiler){% endif %}) {
}



void {{project}}::{{abstractSolver}}::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "{{project}}::{{abstractSolver}}("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "nDim=" << Dimensions << ", "
	   << "order=" << Order
	   << ")";
}



void {{project}}::{{abstractSolver}}::spaceTimePredictor(double* lQhbnd,double* lFhbnd,double** tempSpaceTimeUnknowns,double** tempSpaceTimeFluxUnknowns,double* tempUnknowns,double* tempFluxUnknowns,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& inverseDx,const double dt, double** tempPointForceSources) {
{%- if enableProfiler %}
  _profiler->start("spaceTimePredictor");
{%- endif %}

  constexpr bool useGeneric = false;
  
if(useGeneric) {
  
#if DIMENSIONS==2
  double dx[2];
#else
  double dx[3];
  dx[2] = 1.0/inverseDx[2];
#endif
  dx[0] = 1.0/inverseDx[0];
  dx[1] = 1.0/inverseDx[1];
  
  double* lQhi = new double[{{optNamespace}}::converter::getQhiGenArraySize()];
  double* lFhi = new double[{{optNamespace}}::converter::getFhiGenArraySize()];
  double* Qbnd = new double[{{optNamespace}}::converter::getQhbndGenArraySize()];
  double* Fbnd = new double[{{optNamespace}}::converter::getFhbndGenArraySize()];
  {{optNamespace}}::converter::Qhi_optimised2generic(tempUnknowns, lQhi);
  {{optNamespace}}::converter::Fhi_optimised2generic(tempFluxUnknowns, lFhi);
  {{optNamespace}}::converter::Qhbnd_optimised2generic(lQhbnd, Qbnd);
  {{optNamespace}}::converter::Fhbnd_optimised2generic(lFhbnd, Fbnd);
  
{%- if usePointSources %}
  double* pointForceSources_g[2];
  pointForceSources_g[0] = new double[{{optNamespace}}::converter::getPSiGenArraySize()];
  pointForceSources_g[1] = tempPointForceSources[1];
  {{optNamespace}}::converter::PSi_optimised2generic(tempPointForceSources[0],pointForceSources_g[0]);
{%- else %}
  double** pointForceSources_g = nullptr;
{%- endif %}
  
  
{%- if  isLinear %}
  kernels::aderdg::generic::c::spaceTimePredictorLinear<{{usePointSources}}, {{useSource}}, {{useFlux}}, {{useNCP}}, {{useMaterialParam}}, {{solver}}>(*static_cast<{{solver}}*>(this), Qbnd, Fbnd, tempSpaceTimeUnknowns, tempSpaceTimeFluxUnknowns, lQhi, lFhi, luh, &dx[0], dt, pointForceSources_g);
{%- else %}
  kernels::aderdg::generic::c::spaceTimePredictorNonlinear<{{useSource}}, {{useFlux}}, {{useNCP}}, {{noTimeAveraging}}, {{solver}}>(*static_cast<{{solver}}*>(this), Qbnd, Fbnd, tempSpaceTimeUnknowns, tempSpaceTimeFluxUnknowns, lQhi, lFhi, luh, &dx[0], dt);
{%- endif %}
  
  {{optNamespace}}::converter::Qhi_generic2optimised(lQhi, tempUnknowns);
  {{optNamespace}}::converter::Fhi_generic2optimised(lFhi, tempFluxUnknowns);
  {{optNamespace}}::converter::Qhbnd_generic2optimised(Qbnd, lQhbnd);
  {{optNamespace}}::converter::Fhbnd_generic2optimised(Fbnd, lFhbnd);
  
  delete[] lQhi;
  delete[] lFhi;
  delete[] Qbnd;
  delete[] Fbnd;
{%- if usePointSources %}
  delete[] pointForceSources_g[0];
{%- endif %}
    
    
} else {
  
{%- if useFlux %}
{%- if dimensions == 2 %}
  constexpr int lSi_offset  = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  constexpr int lShi_offset = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**nDim)*nVarPad
{%- else %}
  constexpr int lSi_offset  = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  constexpr int lShi_offset = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**nDim)*nVarPad
{%- endif %}
{%- else %}
  constexpr int lSi_offset  = 0; //no Flux
  constexpr int lShi_offset = 0; //no Flux
{%- endif %}

{%- if  isLinear %}
  {{optNamespace}}::spaceTimePredictorLinear(*static_cast<{{solver}}*>(this), lQhbnd, lFhbnd, tempSpaceTimeUnknowns[0] /*lQi*/, tempSpaceTimeFluxUnknowns[0] /*lFi*/, &tempSpaceTimeFluxUnknowns[0][lSi_offset] /*lSi*/, tempUnknowns /*lQhi*/, tempFluxUnknowns /*lFhi*/, &tempFluxUnknowns[lShi_offset] /*lShi*/, tempSpaceTimeFluxUnknowns[1] /*gradQ*/, tempPointForceSources[0] /*PSi*/, tempPointForceSources[1] /*PSderivatives*/, luh, inverseDx, dt);
{%- else %}
{%- if noTimeAveraging %}
  //No Time Averaging scheme
  {{optNamespace}}::picardLoopNonlinear(*static_cast<{{solver}}*>(this), luh, dt, inverseDx, tempSpaceTimeUnknowns[0], tempSpaceTimeUnknowns[1], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], {% if useNCP %}tempSpaceTimeFluxUnknowns[1]{% else %}nullptr{% endif %} {%- if enableDeepProfiler %}, _profiler.get(){% endif %}); //lSi, gradQ
  {{optNamespace}}::extrapolatorNonlinear(tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], lQhbnd, lFhbnd);
{%- else %}
  {{optNamespace}}::picardLoopNonlinear(*static_cast<{{solver}}*>(this), luh, dt, inverseDx, tempSpaceTimeUnknowns[0], tempSpaceTimeUnknowns[1], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], {% if useNCP %}tempSpaceTimeFluxUnknowns[1]{% else %}nullptr{% endif %} {%- if enableDeepProfiler %}, _profiler.get(){% endif %}); //lSi, gradQ
  {{optNamespace}}::predictorNonlinear(tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], tempUnknowns, tempFluxUnknowns, &tempFluxUnknowns[lShi_offset]);
  {{optNamespace}}::extrapolatorNonlinear(tempUnknowns, tempFluxUnknowns, lQhbnd, lFhbnd);
{%- endif %}
{%- endif %}
  
}
  
{%- if enableProfiler %}
  _profiler->stop("spaceTimePredictor");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::solutionUpdate(double* luh,const double* const lduh,const double dt) {
{%- if enableProfiler %}
  _profiler->start("solutionUpdate");
{%- endif %}
  {{optNamespace}}::solutionUpdate( luh, lduh, dt );
{%- if enableProfiler %}
  _profiler->stop("solutionUpdate");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::volumeIntegral(double* lduh,const double* const lFi,const double* const lFhi,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{%- if enableProfiler %}
  _profiler->start("volumeIntegral");
{%- endif %}

  constexpr bool useGeneric = false;
  
if(useGeneric) {
  
#if DIMENSIONS==2
  double dx[2];
#else
  double dx[3];
  dx[2] = 1.0/inverseDx[2];
#endif
  dx[0] = 1.0/inverseDx[0];
  dx[1] = 1.0/inverseDx[1];
  
  double* lFhi_g = new double[{{optNamespace}}::converter::getFhiGenArraySize()];
  {{optNamespace}}::converter::Fhi_optimised2generic(lFhi, lFhi_g);
{%- if isLinear %}
  kernels::aderdg::generic::c::volumeIntegralLinear<{{useSource}}, {{useFlux}}, NumberOfVariables, Order+1>(lduh,lFhi_g,&dx[0]);
{%- else %}  
  kernels::aderdg::generic::c::volumeIntegralNonlinear<{{useSource}}, {{useFlux}}, {{noTimeAveraging}}, NumberOfVariables, Order+1>(lduh,nullptr,lFhi_g,&dx[0]);
{%- endif %}

  delete[] lFhi_g;
    
    
} else {

{%- if useFlux %}
{%- if dimensions == 2 %}
  {%- if noTimeAveraging %}
  constexpr int lSi_offset  = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  {%- else %}
  constexpr int lShi_offset = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
  {%- endif %}
{%- else %}
  {%- if noTimeAveraging %}
  constexpr int lSi_offset  = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  {%- else %}
  constexpr int lShi_offset = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
  {%- endif %}
{%- endif %}
{%- else %}
  constexpr int lSi_offset  = 0; //no Flux
  constexpr int lShi_offset = 0; //no Flux
{%- endif %}

{%- if noTimeAveraging %}
  //No Time Averaging scheme, lFhi == nullptr
  {{optNamespace}}::volumeIntegral( lduh, lFi, &lFi[lSi_offset], inverseDx );
{%- else %}
  //Time averaging scheme, lFi not required
  {{optNamespace}}::volumeIntegral( lduh, lFhi, &lFhi[lShi_offset], inverseDx );
{%- endif %}

}

{%- if enableProfiler %}
  _profiler->stop("volumeIntegral");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::surfaceIntegral(double* lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{%- if enableProfiler %}
  _profiler->start("surfaceIntegral");
{%- endif %}

  constexpr bool useGeneric = false;
  
if(useGeneric) {
  
#if DIMENSIONS==2
  double dx[2];
#else
  double dx[3];
  dx[2] = 1.0/inverseDx[2];
#endif
  dx[0] = 1.0/inverseDx[0];
  dx[1] = 1.0/inverseDx[1];
  
  double* lFhbnd_g = new double[{{optNamespace}}::converter::getFhbndGenArraySize()];
  {{optNamespace}}::converter::Fhbnd_optimised2generic(lFhbnd, lFhbnd_g);
{%- if isLinear %}
  kernels::aderdg::generic::c::surfaceIntegralLinear<NumberOfVariables, Order+1>(lduh,lFhbnd_g,&dx[0]);
{%- else %}
  kernels::aderdg::generic::c::surfaceIntegralNonlinear<NumberOfVariables, Order+1>(lduh,lFhbnd_g,&dx[0]);
{%- endif %}
  
  delete[] lFhbnd_g;
    
} else {

  {{optNamespace}}::surfaceIntegral( lduh, lFhbnd, inverseDx );
  
}
{%- if enableProfiler %}
  _profiler->stop("surfaceIntegral");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,const double dt,const int normalNonZeroIndex,bool isBoundaryFace, int faceIndex) {
  assertion2(normalNonZeroIndex>=0,dt,normalNonZeroIndex);
  assertion2(normalNonZeroIndex<DIMENSIONS,dt,normalNonZeroIndex);
{%- if enableProfiler %}
  _profiler->start("riemannSolver");
{%- endif %}

constexpr bool useGeneric = false;
  
if(useGeneric) {
  
  double* FL_g = new double[{{optNamespace}}::converter::getFFaceGenArraySize()];
  double* FR_g = new double[{{optNamespace}}::converter::getFFaceGenArraySize()];
  double* QL_g = new double[{{optNamespace}}::converter::getQFaceGenArraySize()];
  double* QR_g = new double[{{optNamespace}}::converter::getQFaceGenArraySize()];

  {{optNamespace}}::converter::FFace_optimised2generic(FL,FL_g);
  {{optNamespace}}::converter::FFace_optimised2generic(FR,FR_g);
  {{optNamespace}}::converter::QFace_optimised2generic(QL,QL_g);
  {{optNamespace}}::converter::QFace_optimised2generic(QR,QR_g);
{%- if isLinear %}
  kernels::aderdg::generic::c::riemannSolverLinear<{{useFlux}},{{useNCP}},{{useMaterialParam}},{{solver}}>(*static_cast<{{solver}}*>(this),FL_g,FR_g,QL_g,QR_g,dt,normalNonZeroIndex);
{%- else %}
  kernels::aderdg::generic::c::riemannSolverNonlinear<{{useNCP}},{{solver}}>(*static_cast<{{solver}}*>(this),FL_g,FR_g,QL_g,QR_g,dt,normalNonZeroIndex);
{%- endif %}
  
  {{optNamespace}}::converter::FFace_generic2optimised(FL_g,FL);
  {{optNamespace}}::converter::FFace_generic2optimised(FR_g,FR);

  delete[] FL_g;  
  delete[] FR_g;  
  delete[] QL_g;  
  delete[] QR_g;
    
} else {

  {{optNamespace}}::riemannSolver(*static_cast<{{solver}}*>(this), FL, FR, QL, QR, dt, normalNonZeroIndex {%- if enableDeepProfiler %}, _profiler.get(){% endif %});
  
}
{%- if enableProfiler %}
  _profiler->stop("riemannSolver");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::boundaryConditions(double* fluxOut,double* stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
{%- if enableProfiler %}
  _profiler->start("boundaryConditions");
{%- endif %}
  {{optNamespace}}::boundaryConditions(*static_cast<{{solver}}*>(this), fluxOut, stateOut, fluxIn, stateIn, cellCentre, cellSize, t, dt, faceIndex, normalNonZero );
{%- if enableProfiler %}
  _profiler->stop("boundaryConditions");
{%- endif %}
}



double {{project}}::{{abstractSolver}}::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{%- if enableProfiler %}
  _profiler->start("stableTimeStepSize");
{%- endif %}
  double d = {{optNamespace}}::stableTimeStepSize(*static_cast<{{solver}}*>(this), luh, inverseDx );
{%- if enableProfiler %}
  _profiler->stop("stableTimeStepSize");
{%- endif %}
  return d;
}



{%- if !patchwiseAdjust %}
void {{project}}::{{abstractSolver}}::adjustSolution(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) {
{%- if enableProfiler %}
  _profiler->start("solutionAdjustment");
{%- endif %}
  {{optNamespace}}::adjustPointSolution(*static_cast<{{solver}}*>(this), luh, center, dx, t, dt );
{%- if enableProfiler %}
  _profiler->stop("solutionAdjustment");
{%- endif %}
}
{%- endif %}


void {{project}}::{{abstractSolver}}::deltaDistribution(const double t,const double dt, const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx, double** tempPointForceSources) {
{%- if usePointSources %}
{%- if enableProfiler %}
  _profiler->start("deltaDistribution");
{%- endif %}
  constexpr bool useGeneric = false;
  
  if(useGeneric) {
    double** tmp = new double*[2];
    tmp[0] = new double[{{optNamespace}}::converter::getPSiGenArraySize()];
    tmp[1] = new double[{{optNamespace}}::converter::getPSiGenArraySize()];
    kernels::aderdg::generic::c::deltaDistribution<{{solver}}>(*static_cast<{{solver}}*>(this), t, dt, center, dx,getNodesPerCoordinateAxis(), tmp);
    
    {{optNamespace}}::converter::PSi_generic2optimised(tmp[0],tempPointForceSources[0]);
    
    delete[] tmp[0];
    delete[] tmp[1];
    delete[] tmp;
  } else {
    {{optNamespace}}::deltaDistribution(*static_cast<{{solver}}*>(this), t, dt, center, dx, tempPointForceSources);
  }
{%- if enableProfiler %}
  _profiler->stop("deltaDistribution");
{%- endif %}
{%- else %}
  //Point sources aren't defined, this method should be empty
{%- endif %}
}


void {{project}}::{{abstractSolver}}::faceUnknownsProlongation(double* lQhbndFine,double* lFhbndFine,const double* lQhbndCoarse,const double* lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{%- if enableProfiler %}
  _profiler->start("faceUnknownsProlongation");
{%- endif %}
  {{optNamespace}}::faceUnknownsProlongation( lQhbndFine, lFhbndFine, lQhbndCoarse, lFhbndCoarse, coarseGridLevel, fineGridLevel, subfaceIndex);
{%- if enableProfiler %}
  _profiler->start("faceUnknownsProlongation");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::faceUnknownsRestriction(double* lQhbndCoarse,double* lFhbndCoarse,const double* lQhbndFine,const double* lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{%- if enableProfiler %}
  _profiler->start("faceUnknownsRestriction");
{%- endif %}
  {{optNamespace}}::faceUnknownsRestriction( lQhbndCoarse, lFhbndCoarse, lQhbndFine, lFhbndFine, coarseGridLevel, fineGridLevel, subfaceIndex);
{%- if enableProfiler %}
  _profiler->stop("faceUnknownsRestriction");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::volumeUnknownsProlongation(double* luhFine,const double* luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{%- if enableProfiler %}
  _profiler->start("volumeUnknownsProlongation");
{%- endif %}
  {{optNamespace}}::volumeUnknownsProlongation( luhFine, luhCoarse, coarseGridLevel, fineGridLevel, subcellIndex);
{%- if enableProfiler %}
  _profiler->stop("volumeUnknownsProlongation");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::volumeUnknownsRestriction(double* luhCoarse,const double* luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{%- if enableProfiler %}
  _profiler->start("volumeUnknownsRestriction");
{%- endif %}
  {{optNamespace}}::volumeUnknownsRestriction( luhCoarse, luhFine, coarseGridLevel, fineGridLevel, subcellIndex);
{%- if enableProfiler %}
  _profiler->stop("volumeUnknownsRestriction");
{%- endif %}
}

//--------

void {{project}}::{{abstractSolver}}::abortWithMsg(const char* const msg) {
	// verbosily fail even without assertions turned on
	puts(msg);
	abort();
}

void {{project}}::{{abstractSolver}}::flux(const double* const Q,double** F) {
  abortWithMsg("If this operation is entered (flux), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::algebraicSource(const double* const Q,double* S) {
  abortWithMsg("If this operation is entered (algebraicSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
        
void {{project}}::{{abstractSolver}}::nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) {
  abortWithMsg("If this operation is entered (nonConservativeProduct), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::pointSource(const double* const x,const double t,const double dt, double* forceVector, double* x0, int n) {
  abortWithMsg("If this operation is entered (pointSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}