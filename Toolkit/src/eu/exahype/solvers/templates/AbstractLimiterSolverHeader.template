#ifndef __{{abstractSolver}}_CLASS_HEADER__
#define __{{abstractSolver}}_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================

#include <string>

#include "exahype/solvers/LimitingADERDGSolver.h"
#include "{{ADERDGAbstractSolver}}.h"
#include "{{FVAbstractSolver}}.h"

namespace {{project}}{
  class {{abstractSolver}};
}

class {{project}}::{{abstractSolver}}: public exahype::solvers::LimitingADERDGSolver {  
  public:
    static constexpr int NumberOfVariables  = {{project}}::{{ADERDGAbstractSolver}}::NumberOfVariables;
    static constexpr int Order              = {{project}}::{{ADERDGAbstractSolver}}::Order;
    static constexpr int GhostLayerWidth    = {{project}}::{{FVAbstractSolver}}::GhostLayerWidth;
  
    {{abstractSolver}}(std::string identifier, std::unique_ptr<exahype::solvers::ADERDGSolver> solver, std::unique_ptr<exahype::solvers::FiniteVolumesSolver> limiter, const double DMPRelaxationParameter, const double DMPDifferenceScaling, const int iterationsToCureTroubledCell);
    
    void projectOnFVLimiterSpace(const double* const luh, double* const lim) const override;
    void projectOnDGSpace(const double* const lim, double* const luh) const override;
    bool discreteMaximumPrincipleAndMinAndMaxSearch(const double* const luh, double* boundaryMinPerVariables, double* boundaryMaxPerVariables) override;
    void findCellLocalMinAndMax(const double* const luh, double* const localMinPerVariables, double* const localMaxPerVariable) override;
    void findCellLocalLimiterMinAndMax(const double* const lim, double* const localMinPerObservable, double* const localMaxPerObservable) override;
};

#endif // __{{abstractSolver}}_CLASS_HEADER__
