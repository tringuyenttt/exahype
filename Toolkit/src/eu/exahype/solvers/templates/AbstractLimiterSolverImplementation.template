// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "{{abstractSolver}}.h"

#include "kernels/limiter/generic/Limiter.h"


// Just call parent constructor
{{project}}::{{abstractSolver}}::{{abstractSolver}}(std::unique_ptr<exahype::solvers::ADERDGSolver> solver, std::unique_ptr<exahype::solvers::FiniteVolumesSolver> limiter, const double DMPRelaxationParameter, const double DMPDifferenceScaling, const int iterationsToCureTroubledCell):
  exahype::solvers::LimitingADERDGSolver("LimitingADERDG" /* identifier */, std::move(solver), std::move(limiter), DMPRelaxationParameter, DMPDifferenceScaling, iterationsToCureTroubledCell) {
}

void {{project}}::{{abstractSolver}}::projectOnFVLimiterSpace(const double* const luh, double* const lim) const {
  kernels::limiter::generic::c::projectOnFVLimiterSpace(luh, NumberOfVariables, Order+1, GhostLayerWidth, lim);
}

void {{project}}::{{abstractSolver}}::projectOnDGSpace(const double* const lim, double* const luh) const {
  kernels::limiter::generic::c::projectOnDGSpace(lim, NumberOfVariables, Order+1, GhostLayerWidth, luh);
}

bool {{project}}::{{abstractSolver}}::discreteMaximumPrincipleAndMinAndMaxSearch(const double* const luh, double* boundaryMinPerVariables, double* boundaryMaxPerVariables) {
  return kernels::limiter::generic::c::discreteMaximumPrincipleAndMinAndMaxSearch(luh, _solver.get(), _DMPMaximumRelaxationParameter, _DMPDifferenceScaling, boundaryMinPerVariables, boundaryMaxPerVariables);
}

void {{project}}::{{abstractSolver}}::findCellLocalMinAndMax(const double* const luh, double* const localMinPerVariables, double* const localMaxPerVariable) {
  kernels::limiter::generic::c::findCellLocalMinAndMax(luh, _solver.get(), localMinPerVariables, localMaxPerVariable);
}
void {{project}}::{{abstractSolver}}::findCellLocalLimiterMinAndMax(const double* const lim, double* const localMinPerObservable, double* const localMaxPerObservable) {
  kernels::limiter::generic::c::findCellLocalLimiterMinAndMax(lim, _solver.get(), GhostLayerWidth, localMinPerObservable,localMaxPerObservable);
}